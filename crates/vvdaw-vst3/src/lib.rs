//! VST3 plugin host implementation.
//!
//! This crate implements the VST3 plugin hosting functionality,
//! wrapping VST3 plugins to implement our common Plugin trait.
//!
//! ## VST3 SDK
//!
//! This crate generates Rust bindings from the MIT-licensed VST3 SDK at build time.
//! The bindings are generated using bindgen from the official Steinberg VST3 SDK.
//!
//! ## Architecture
//!
//! VST3 uses COM-style interfaces. The loading flow is:
//! 1. Load the VST3 dynamic library (`.vst3` bundle)
//! 2. Call `GetPluginFactory()` to get the factory interface
//! 3. Query factory for available plugin classes
//! 4. Create instances of `IComponent` and `IAudioProcessor`
//! 5. Initialize and activate for audio processing

use std::path::Path;
use vvdaw_plugin::{PluginError, PluginInfo};

mod com;
mod ipc;
mod loader;
mod multiproc;
mod shm;
mod wrapper;

pub use ipc::{ControlMessage, Event, ProcessState, ResponseMessage, SharedAudioBuffer};
pub use loader::Vst3Loader;
pub use multiproc::MultiProcessPlugin;
pub use shm::SharedMemory;
pub use wrapper::Vst3Plugin;

/// VST3 FFI bindings (auto-generated by bindgen in build.rs)
#[allow(unsafe_code)]
#[allow(non_upper_case_globals)]
#[allow(non_camel_case_types)]
#[allow(non_snake_case)]
#[allow(dead_code)]
#[allow(clippy::all)]
#[allow(warnings)]
mod ffi {
    include!(concat!(env!("OUT_DIR"), "/vst3_bindings.rs"));
}

/// Scan a directory for VST3 plugins
///
/// Convenience function that delegates to `Vst3Loader::scan`.
pub fn scan_plugins<P: AsRef<Path>>(path: P) -> Result<Vec<PluginInfo>, PluginError> {
    Vst3Loader::scan(path)
}

/// Load a VST3 plugin from a path
///
/// Convenience function that delegates to `Vst3Loader::load`.
pub fn load_plugin<P: AsRef<Path>>(path: P) -> Result<Vst3Plugin, PluginError> {
    Vst3Loader::load(path)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_scan_plugins() {
        // Test that scan_plugins delegates to loader
        let result = scan_plugins("/nonexistent");
        assert!(result.is_ok());
        assert!(result.unwrap().is_empty());
    }

    #[test]
    fn test_load_plugin_not_implemented() {
        // Loading should fail until implemented
        let result = load_plugin("/nonexistent.vst3");
        assert!(result.is_err());
    }
}
